0) Now we are NPE-ing on the MarshallPlan iterable constructor because of
   string, [in] string, and buffer. The problem is that for all of these, the
   amount of memory to allocate is inferred from the arguments to the DLL --
   it can't be known in advance. This requires a newer and groovier marshalling
   scheme.

0A) Some other code is failing to resolve because of inability to parse
    callbacks (e.g. WndProc). So let's sort that out so we at least have the
    whole data model in memory at once.

1) Add support for gdiobj/handle basic types
       DONE.
2) Add support for string as a return type
       [ ] Just hack it for now, so that stuff compiles (hack to void)
           DONE.
       [ ] Update suneidoc
           DONE.
3) As soon as CheckLibraries() / tests work
       [ ] push jsdi
           DONE.
       [ ] push jsuneido
           DONE.
4) Implement general marshalling algorithm
5) Implement string/buffer types, including Buffer() built-in

...) Later:
       [ ] Collect marshalling and type stats
       [ ] Optimize

        BUILD ISSUES
        -- doxygen
            [ ] Modify header style (include guard, then doxygen docs)
            [ ] Modify auto-generated header style.
            [ ] Current number of warnings: 149
        -- cppcheck


================================================================================
OBJECT LIFETIMES
================================================================================
Object lifetimes are valid only for that native invocation.
    See http://developer.android.com/training/articles/perf-jni.html#local_and_global_references

    KEY FUNCTIONS:
        IsSameObject() -- never use == !!!
        NewGlobalRef()
        DeleteGlobalRef()

The only way to get non-local references is via the functions NewGlobalRef and NewWeakGlobalRef.

If you want to hold on to a reference for a longer period, you must use a "global" reference. The NewGlobalRef function takes the local reference as an argument and returns a global one. The global reference is guaranteed to be valid until you call DeleteGlobalRef.

This pattern is commonly used when caching a jclass returned from FindClass, e.g.:

jclass localClass = env->FindClass("MyClass");
jclass globalClass = reinterpret_cast<jclass>(env->NewGlobalRef(localClass));
All JNI methods accept both local and global references as arguments. It's possible for references to the same object to have different values. For example, the return values from consecutive calls to NewGlobalRef on the same object may be different. To see if two references refer to the same object, you must use the IsSameObject function. Never compare references with == in native code.



================================================================================
NECESSITY OF DOING CLEANUP OF LOCAL REFERENCES
================================================================================

Programmers are required to "not excessively allocate" local references. In
practical terms this means that if you're creating large numbers of local
references, perhaps while running through an array of objects, you should free
them manually with DeleteLocalRef instead of letting JNI do it for you. The
implementation is only required to reserve slots for 16 local references, so if
you need more than that you should either delete as you go or use
EnsureLocalCapacity/PushLocalFrame to reserve more.

Note that jfieldIDs and jmethodIDs are opaque types, not object references, and
should not be passed to NewGlobalRef. The raw data pointers returned by
functions like GetStringUTFChars and GetByteArrayElements are also not objects.
(They may be passed between threads, and are valid until the matching Release
call.)

One unusual case deserves separate mention. If you attach a native thread with
AttachCurrentThread, the code you are running will never automatically free
local references until the thread detaches. Any local references you create will
have to be deleted manually. In general, any native code that creates local
references in a loop probably needs to do some manual deletion.


================================================================================
ON STRUCT PACKING/ALIGNMENT
================================================================================

See here:

http://msdn.microsoft.com/en-us/library/windows/desktop/aa383745(v=vs.85).aspx

Controlling Structure Packing

Projects should be compiled to use the default structure packing, which is
currently 8 bytes because the largest integral type is 8 bytes. Doing so ensures
that all structure types within the header files are compiled into the
application with the same alignment the Windows API expects. It also ensures
that structures with 8-byte values are properly aligned and will not cause
alignment faults on processors that enforce data alignment.