
...) Later:
       [ ] Collect marshalling and type stats
       [ ] Optimize

        BUILD ISSUES
        -- doxygen
            [ ] Modify header style (include guard, then doxygen docs)
            [ ] Modify auto-generated header style.
            [ ] Current number of warnings: 149
        -- cppcheck


================================================================================
DLL INTERFACE GRAMMAR CLAMPDOWNS
================================================================================

1) pointers to basic types should not be permitted AT ALL. There is no...point
   ...allowing them. If user desperately needs, can wrap them in a STRUCT, which
   will give better behaviour anyway.

2) string[N] and buffer[N] should not be permitted in dll params. If user
   desperately needs, can wrap them in a STRUCT.

3) 'float' and 'double' return values must not be permitted, because such values
   are not returned in EAX/EDX but rather at the top of the floating point
   register stack (FP0). This breaks our stdcall invocation routine.

================================================================================
OBJECT LIFETIMES
================================================================================
Object lifetimes are valid only for that native invocation.
    See http://developer.android.com/training/articles/perf-jni.html#local_and_global_references

    KEY FUNCTIONS:
        IsSameObject() -- never use == !!!
        NewGlobalRef()
        DeleteGlobalRef()

The only way to get non-local references is via the functions NewGlobalRef and NewWeakGlobalRef.

If you want to hold on to a reference for a longer period, you must use a "global" reference. The NewGlobalRef function takes the local reference as an argument and returns a global one. The global reference is guaranteed to be valid until you call DeleteGlobalRef.

This pattern is commonly used when caching a jclass returned from FindClass, e.g.:

jclass localClass = env->FindClass("MyClass");
jclass globalClass = reinterpret_cast<jclass>(env->NewGlobalRef(localClass));
All JNI methods accept both local and global references as arguments. It's possible for references to the same object to have different values. For example, the return values from consecutive calls to NewGlobalRef on the same object may be different. To see if two references refer to the same object, you must use the IsSameObject function. Never compare references with == in native code.



================================================================================
NECESSITY OF DOING CLEANUP OF LOCAL REFERENCES
================================================================================

Programmers are required to "not excessively allocate" local references. In
practical terms this means that if you're creating large numbers of local
references, perhaps while running through an array of objects, you should free
them manually with DeleteLocalRef instead of letting JNI do it for you. The
implementation is only required to reserve slots for 16 local references, so if
you need more than that you should either delete as you go or use
EnsureLocalCapacity/PushLocalFrame to reserve more.

Note that jfieldIDs and jmethodIDs are opaque types, not object references, and
should not be passed to NewGlobalRef. The raw data pointers returned by
functions like GetStringUTFChars and GetByteArrayElements are also not objects.
(They may be passed between threads, and are valid until the matching Release
call.)

One unusual case deserves separate mention. If you attach a native thread with
AttachCurrentThread, the code you are running will never automatically free
local references until the thread detaches. Any local references you create will
have to be deleted manually. In general, any native code that creates local
references in a loop probably needs to do some manual deletion.


================================================================================
ON STRUCT PACKING/ALIGNMENT
================================================================================

See here:

http://msdn.microsoft.com/en-us/library/windows/desktop/aa383745(v=vs.85).aspx

Controlling Structure Packing

Projects should be compiled to use the default structure packing, which is
currently 8 bytes because the largest integral type is 8 bytes. Doing so ensures
that all structure types within the header files are compiled into the
application with the same alignment the Windows API expects. It also ensures
that structures with 8-byte values are properly aligned and will not cause
alignment faults on processors that enforce data alignment.